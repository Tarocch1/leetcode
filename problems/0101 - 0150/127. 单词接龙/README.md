给定两个单词（*beginWord* 和 *endWord*）和一个字典，找到从 *beginWord* 到 *endWord* 的最短转换序列的长度。转换需遵循如下规则：

1. 每次转换只能改变一个字母。
2. 转换过程中的中间单词必须是字典中的单词。

**说明:**

- 如果不存在这样的转换序列，返回 0。
- 所有单词具有相同的长度。
- 所有单词只由小写字母组成。
- 字典中不存在重复的单词。
- 你可以假设 *beginWord* 和 *endWord* 是非空的，且二者不相同。

**示例 1:**

```
输入:
beginWord = "hit",
endWord = "cog",
wordList = ["hot","dot","dog","lot","log","cog"]

输出: 5

解释: 一个最短转换序列是 "hit" -> "hot" -> "dot" -> "dog" -> "cog",
     返回它的长度 5。
```

**示例 2:**

```
输入:
beginWord = "hit"
endWord = "cog"
wordList = ["hot","dot","dog","lot","log"]

输出: 0

解释: endWord "cog" 不在字典中，所以无法进行转换。
```

**思路:**

广度优先搜索，首先在字典中找出所有可以从 beginWord 通过一次变化得到的单词，再分别对这些单词进行同样的操作，并不断查找下去，直到找到 endWord。为了避免出现循环查找的问题，记录已经查找到的单词，当这个单词再次被查找到时，不将其加入等待查找的队列。

为了能快速找到某一个单词通过一次变化可以得到的新单词，在开始查找之前对字典进行预操作。

例如，字典中一个单词是 "hot"，这个单词可以通过所有符合 "\*ot"、"h\*t"、"ho\*" 的单词通过一次变化的来，因此将这三种情况与 "hot" 建立映射。之后当需要查找 "hit" 时，发现其符合 "h\*t" 结构，因此直接查找到 "hot"。
