给你一个整数数组 `nums`，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。

**示例 1:**

```
输入: [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。
```

**示例 2:**

```
输入: [-2,0,-1]
输出: 0
解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。
```

**思路:**

采用动态规划。

首先想到使用 `dp[i]` 表示以第 i 位结尾的子数组的最大乘积，则 `dp[i] = Math.max(nums[i], dp[i - 1] * nums[i])`。

但是这里会有问题，乘法有其特殊性“负负得正”。假如数组为 `[1, 2, -3, -4]`，按照上述算法，`dp[2] = -3`，`dp[3] = 12`，这显然不是正确结果。原因在于我们在计算 `dp[2]` 时候，结果为负，没有考虑到下一位也为负时的情况，而是简单地挑选了一个最大值，我们在计算 `dp[3]` 的时候，也没有考虑到前面存在绝对值较大的负值的情况，最终导致结果出错。

为解决以上问题，我们在计算时，不仅保存每一位结尾的最大值，同时还保存最小值，这样在计算下一位最大值时，将最小值也纳入比较的范围，最终得到真正的最大值。
