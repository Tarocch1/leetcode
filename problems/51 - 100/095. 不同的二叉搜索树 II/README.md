给定一个整数 *n*，生成所有由 1 ... *n* 为节点所组成的 **二叉搜索树**。

**示例:**

```
输入：3
输出：
[
  [1,null,3,2],
  [3,2,null,1],
  [3,1,null,null,2],
  [2,1,3],
  [1,null,2,null,3]
]
解释：
以上的输出对应以下 5 种不同结构的二叉搜索树：

    1         3     3      2      1
     \       /     /      / \      \
      3     2     1      1   3      2
     /     /       \                 \
    2     1         2                 3j
```

**提示:**

- `0 <= n <= 8`

**思路:**

二叉搜索树的性质是根节点的值大于左子树的所有值，小于右子树的所有值，并且左子树与右子树也都是二叉搜索树。

因此，可以编写一个递归的 `generate(start, end)` 函数，生成包含从 `start` 到 `end` 的二叉搜索树，函数遍历从 `start` 到 `end` 的所有值，依次作为根节点。假设根节点为 `i`，则左子树通过 `generate(start, i - 1)` 生成，右子树通过 `generate(i + 1, end)` 生成，左右子树生成好后，与根节点组合即可。

本题的结果可以通过 `generate(1, n)` 生成。
