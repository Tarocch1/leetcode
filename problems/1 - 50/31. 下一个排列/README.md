实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须 [原地](https://zh.wikipedia.org/wiki/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95) 修改，只允许使用额外常数空间。

以下是一些例子，输入位于左侧列，其相应输出位于右侧列。

`1,2,3` → `1,3,2`

`3,2,1` → `1,2,3`

`1,1,5` → `1,5,1`

**思路:**

从后向前遍历数组，如果发现整个数组依次递减，反向数组并结束。

如果发现某一位比前一位大，则修改前一位可获得下一个更大排列，假设这一位下标为 i。

不难发现，应该将 i - 1 位修改为 [i, len - 1] 中比 i - 1位大的最小值，由于 [i, len - 1] 逐渐递减，则从后向前遍历，查找到大于 i - 1 位值的数，交换位置，假设位置为 j。

不难发现，j 位的新值（原 i - 1 位值）小于 j - 1位，同时又大于 j + 1 位，因此，此时 [i, len - 1] 依然逐渐递减。为保证得到下一位更大排序，我们需要将这一部分重新从小到大排列，由于已经是逐渐递减，直接首位依次交换即可。
